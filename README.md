## LESSON 62

1) Что такое массив? Зачем нужны массивы?

   Массив — это коллекция данных одного типа, размещённых в памяти последовательно. Массивы позволяют хранить и обрабатывать группы связанных данных, такие как списки, таблицы и др.

2) Зачем нужно объявлять массивы?

   Объявление массивов нужно для выделения памяти под хранение данных, определения их типа и размера. Это позволяет компилятору организовать управление памятью эффективно.

3) Как объявляются массивы в школьном алгоритмическом языке и в Паскале?

В школьном алгоритмическом языке: массив A[1..N]

В Паскале: var A: array[1..N] of Integer;

4) Почему элементы массива расположены в памяти рядом?

   Элементы массива располагаются рядом для улучшения производительности при доступе к данным, так как это минимизирует время доступа к памяти из-за кэширования.

5) Как обращаются к элементу массива?

   К элементу массива обращаются по индексу: A[i], где i — индекс элемента.

6) Могут ли индексы элементов массива начинаться с 0? С-5?

   Да, в некоторых языках, таких как C++, индексы могут начинаться с 0. В Паскале индексы могут начинаться с 1, но теоретически возможно задать массив с любым начальным индексом, например -5.

7) Почему размер массива лучше вводить как константу, а не как число?

   Использование константы позволяет избежать ошибок, связанных с изменением размера в дальнейшем и упрощает поддержку кода.

8) Как ввести массив и вывести его на экран?

   Ввод массива:

   
pascal Копировать кодfor i := 1 to N do
      readln(A[i]);

   Вывод массива:

   
pascal Копировать кодfor i := 1 to N do
      writeln(A[i]);

9) Как заполнить массив случайными числами?
   В Паскале:

   
pascal Копировать кодfor i := 1 to N do
      A[i] := Random(Range);

Операции с массивом:

Заполните массив элементами арифметической прогрессии.
   
pascal Копировать кодvar a, d: Integer;
   for i := 1 to N do
      A[i] := a + (i-1) * d;

Заполните массив степенями числа 2 (от 2¹ до 2ᴺ).
   
pascal Копировать кодfor i := 1 to N do
      A[i] := Power(2, i);

Заполните массив первыми числами Фибоначчи.
   
pascal Копировать кодA[1] := 0; A[2] := 1;
   for i := 3 to N do
      A[i] := A[i-1] + A[i-2];

Заполните массив из N элементов случайными целыми числами в диапазоне 1..N с перестановкой.
Постройте случайную перестановку чисел от 1 до N так, чтобы первое число было 5.
Заполните массив случайными числами в диапазоне 20..100 и подсчитайте чётные и нечётные.
Заполните массив случайными числами в диапазоне 100..200 и подсчитайте элементы с чётной второй цифрой с конца.

## LESSON 63

1) При поиске индекса максимального элемента не нужно хранить само значение максимального элемента, потому что по индексу элемента можно всегда определить его значение.

2) Реверс массива — это перестановка его элементов в обратном порядке: первый элемент становится последним, а последний — первым.

3) Неправильное обращение к индексам элементов массива. Начинающие программисты забывают учесть особенности индексации, что приводит к неправильному обращению к элементам массива и, следовательно, к некорректному результату.

Неправильное использование временной переменной. Начинающие программисты забывают создать временную переменную или неправильно присваивают ей значение. 

Забывание использовать ссылки на массивы. Вместо этого программисты пытаются работать с самим массивом, что может привести к непредсказуемым результатам. 

Цикл по всему массиву. В результате каждое значение перемещается два раза и оказывается на своём исходном месте. 

4) Некоторые проблемы и ошибки, которые могут возникнуть при циклическом сдвиге массива вправо:

Выход за границы массива. Если не проверить правильность индексов при сдвиге, это может привести к непредсказуемому поведению программы или к возникновению ошибки. 

Потеря данных. Например, если не сохранить последний элемент массива перед сдвигом, то он может быть перезаписан и потерян. 

Неправильный результат. Некорректная логика сдвига массива может привести к неправильному результату. Например, если по ошибке сдвинуть элементы массива не на одну позицию вправо, а на более чем это предусмотрено.

6) Чтобы определить, что элемент не найден при использовании определённого алгоритма поиска, можно проверить, был ли просмотрен весь массив. Если да, значит, в исходном массиве нет элемента, удовлетворяющего условию задачи.

7) Выход за границы массива — это частный случай переполнения буфера, когда индекс, с помощью которого обращаются к элементам массива, превышает допустимое значение. 

Опасность выхода за границы массива заключается в том, что программа обращается к памяти, которая не назначена массиву. Это может привести к следующим последствиям:

Неправильное поведение программы. 

Сбой программы из-за ошибки сегментации. 

Попытка выполнить запись в память, которая помечена как доступная только для чтения. Это может привести к аварийному завершению работы программы. 

Содержание конфиденциальной информации в памяти, которая может быть закрытами ключами или другими учётными данными пользователя. 

Недействительный или защищённый адрес памяти. 

Изменение значения памяти из-за обращения к ней другой программы или потока. 

8) Очевидный алгоритм отбора части элементов одного массива в другой: 

Создать два массива: один для исходных элементов, другой для выбранных элементов. 

Пройти по всем элементам исходного массива. 

Для каждого элемента проверить, соответствует ли он условию отбора. 

Если элемент соответствует условию, добавить его в новый массив. 

Почему этот алгоритм часто не используется:

Он требует дополнительной памяти для создания нового массива, что может быть неэффективно с точки зрения использования ресурсов. 

Дополнительные шаги по созданию нового массива и добавлению элементов могут замедлить выполнение программы, особенно при больших объёмах данных. 

Существуют более оптимизированные подходы, такие как использование фильтрации или преобразования исходного массива с использованием встроенных функций языка программирования, что может быть более эффективным и кратким способом решения задачи. 
